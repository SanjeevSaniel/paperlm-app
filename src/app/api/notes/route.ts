import { auth } from '@clerk/nextjs/server';
import { NotesRepository } from '@/lib/repositories/notesRepository';
import { UserRepository } from '@/lib/repositories/userRepository';
import { SessionRepository } from '@/lib/repositories/sessionRepository';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();
    const body = await request.json();
    const { title, content, sessionId, documentIds = [], tags = [], isAutoGenerated = false, model, tokenCount } = body;

    if (!title || !content || !sessionId) {
      return NextResponse.json({ error: 'Title, content, and session ID are required' }, { status: 400 });
    }

    let user = null;
    if (userId) {
      user = await UserRepository.findByClerkId(userId);
    }

    // Create new note
    const note = await NotesRepository.create({
      userId: user?.id || 'anonymous',
      sessionId: sessionId,
      title: title,
      content: content,
      documentIds: documentIds,
      tags: tags,
      isAutoGenerated: isAutoGenerated,
      model: model,
      tokenCount: tokenCount,
    });

    if (!note) {
      return NextResponse.json({ error: 'Failed to create note' }, { status: 500 });
    }

    // Update session tracking
    if (user) {
      await SessionRepository.incrementNoteCount(sessionId);
    }

    return NextResponse.json({
      note,
      success: true,
    });

  } catch (error) {
    console.error('Notes create error:', error);
    return NextResponse.json(
      { error: 'Failed to create note' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { userId } = await auth();
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    const noteId = searchParams.get('noteId');
    const search = searchParams.get('search');
    const tag = searchParams.get('tag');
    const autoGenerated = searchParams.get('autoGenerated');

    if (noteId) {
      // Get specific note
      const note = await NotesRepository.findById(noteId);
      
      if (!note) {
        return NextResponse.json({ error: 'Note not found' }, { status: 404 });
      }

      // Authorization check
      if (userId) {
        const user = await UserRepository.findByClerkId(userId);
        if (user && note.userId !== user.id) {
          return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
        }
      } else if (sessionId && note.sessionId !== sessionId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
      }

      return NextResponse.json({ note });
    } else if (sessionId) {
      // Get notes for session
      let notes: any[] = [];
      
      if (userId) {
        const user = await UserRepository.findByClerkId(userId);
        if (user) {
          if (autoGenerated === 'true') {
            notes = await NotesRepository.findAutoGeneratedBySession(sessionId);
            // Filter by user
            notes = notes.filter(note => note.userId === user.id);
          } else if (search) {
            notes = await NotesRepository.search(user.id, search);
            // Filter by session
            notes = notes.filter(note => note.sessionId === sessionId);
          } else if (tag) {
            notes = await NotesRepository.findByTag(user.id, tag);
            // Filter by session
            notes = notes.filter(note => note.sessionId === sessionId);
          } else {
            notes = await NotesRepository.findByUserAndSession(user.id, sessionId);
          }
        }
      } else {
        if (autoGenerated === 'true') {
          notes = await NotesRepository.findAutoGeneratedBySession(sessionId);
        } else {
          notes = await NotesRepository.findBySessionId(sessionId);
        }
      }

      return NextResponse.json({
        notes,
        count: notes.length,
      });
    } else if (userId) {
      // Get all notes for user
      const user = await UserRepository.findByClerkId(userId);
      if (!user) {
        return NextResponse.json({ error: 'User not found' }, { status: 404 });
      }

      let notes = [];
      if (search) {
        notes = await NotesRepository.search(user.id, search);
      } else if (tag) {
        notes = await NotesRepository.findByTag(user.id, tag);
      } else {
        notes = await NotesRepository.findByUserId(user.id);
      }

      return NextResponse.json({
        notes,
        count: notes.length,
      });
    } else {
      return NextResponse.json({ error: 'Session ID or user authentication is required' }, { status: 400 });
    }

  } catch (error) {
    console.error('Notes fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch notes' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const { userId } = await auth();
    const body = await request.json();
    const { noteId, title, content, tags, sessionId } = body;

    if (!noteId) {
      return NextResponse.json({ error: 'Note ID is required' }, { status: 400 });
    }

    // Find the note
    const note = await NotesRepository.findById(noteId);
    if (!note) {
      return NextResponse.json({ error: 'Note not found' }, { status: 404 });
    }

    // Authorization check
    if (userId) {
      const user = await UserRepository.findByClerkId(userId);
      if (user && note.userId !== user.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
      }
    } else if (sessionId && note.sessionId !== sessionId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    // Update the note
    const updatedNote = await NotesRepository.update(noteId, {
      title: title || note.title,
      content: content || note.content,
      tags: tags || note.tags,
    });

    if (!updatedNote) {
      return NextResponse.json({ error: 'Failed to update note' }, { status: 500 });
    }

    return NextResponse.json({
      note: updatedNote,
      success: true,
    });

  } catch (error) {
    console.error('Notes update error:', error);
    return NextResponse.json(
      { error: 'Failed to update note' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { userId } = await auth();
    const { searchParams } = new URL(request.url);
    const noteId = searchParams.get('noteId');
    const sessionId = searchParams.get('sessionId');

    if (!noteId) {
      return NextResponse.json({ error: 'Note ID is required' }, { status: 400 });
    }

    // Find the note
    const note = await NotesRepository.findById(noteId);
    if (!note) {
      return NextResponse.json({ error: 'Note not found' }, { status: 404 });
    }

    // Authorization check
    if (userId) {
      const user = await UserRepository.findByClerkId(userId);
      if (user && note.userId !== user.id) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
      }
    } else if (sessionId && note.sessionId !== sessionId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    // Delete the note
    const deleted = await NotesRepository.delete(noteId);
    if (!deleted) {
      return NextResponse.json({ error: 'Failed to delete note' }, { status: 500 });
    }

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('Notes delete error:', error);
    return NextResponse.json(
      { error: 'Failed to delete note' },
      { status: 500 }
    );
  }
}