import { db } from '../neon';
import { notes, type Note, type NewNote } from '@/db/schema';
import { eq, and, desc, like } from 'drizzle-orm';

export class NotesRepository {
  
  // Create new note
  static async create(noteData: NewNote): Promise<Note | null> {
    try {
      const result = await db.insert(notes).values({
        ...noteData,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      return result[0] || null;
    } catch (error) {
      console.error('Error creating note:', error);
      return null;
    }
  }

  // Find note by ID
  static async findById(id: string): Promise<Note | null> {
    try {
      const result = await db.select().from(notes).where(eq(notes.id, id)).limit(1);
      return result[0] || null;
    } catch (error) {
      console.error('Error finding note by ID:', error);
      return null;
    }
  }

  // Find notes by user ID
  static async findByUserId(userId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(eq(notes.userId, userId))
        .orderBy(desc(notes.updatedAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by user ID:', error);
      return [];
    }
  }

  // Find notes by session ID
  static async findBySessionId(sessionId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(eq(notes.sessionId, sessionId))
        .orderBy(desc(notes.updatedAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by session ID:', error);
      return [];
    }
  }

  // Find notes by user and session
  static async findByUserAndSession(userId: string, sessionId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(and(
          eq(notes.userId, userId),
          eq(notes.sessionId, sessionId)
        ))
        .orderBy(desc(notes.updatedAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by user and session:', error);
      return [];
    }
  }

  // Find auto-generated notes by session
  static async findAutoGeneratedBySession(sessionId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(and(
          eq(notes.sessionId, sessionId),
          eq(notes.isAutoGenerated, true)
        ))
        .orderBy(desc(notes.createdAt));
      return result;
    } catch (error) {
      console.error('Error finding auto-generated notes by session:', error);
      return [];
    }
  }

  // Search notes by title or content
  static async search(userId: string, searchTerm: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(and(
          eq(notes.userId, userId),
          like(notes.title, `%${searchTerm}%`)
        ))
        .orderBy(desc(notes.updatedAt));
      return result;
    } catch (error) {
      console.error('Error searching notes:', error);
      return [];
    }
  }

  // Find notes by document IDs
  static async findByDocumentIds(userId: string, documentIds: string[]): Promise<Note[]> {
    try {
      // This is a simplified approach - in a real implementation, you might want to use 
      // JSON operators to search within the documentIds array
      const result = await db
        .select()
        .from(notes)
        .where(eq(notes.userId, userId))
        .orderBy(desc(notes.updatedAt));
      
      // Filter in memory for now (can be optimized with proper JSON queries)
      return result.filter(note => {
        const noteDocIds = note.documentIds as string[] || [];
        return documentIds.some(id => noteDocIds.includes(id));
      });
    } catch (error) {
      console.error('Error finding notes by document IDs:', error);
      return [];
    }
  }

  // Update note
  static async update(id: string, noteData: Partial<NewNote>): Promise<Note | null> {
    try {
      const result = await db
        .update(notes)
        .set({
          ...noteData,
          updatedAt: new Date(),
        })
        .where(eq(notes.id, id))
        .returning();
      return result[0] || null;
    } catch (error) {
      console.error('Error updating note:', error);
      return null;
    }
  }

  // Update note content
  static async updateContent(id: string, title: string, content: string): Promise<Note | null> {
    try {
      const result = await db
        .update(notes)
        .set({
          title,
          content,
          updatedAt: new Date(),
        })
        .where(eq(notes.id, id))
        .returning();
      return result[0] || null;
    } catch (error) {
      console.error('Error updating note content:', error);
      return null;
    }
  }

  // Add tags to note
  static async addTags(id: string, newTags: string[]): Promise<Note | null> {
    try {
      const note = await this.findById(id);
      if (!note) return null;

      const existingTags = note.tags as string[] || [];
      const updatedTags = [...new Set([...existingTags, ...newTags])];

      return await this.update(id, { tags: updatedTags });
    } catch (error) {
      console.error('Error adding tags to note:', error);
      return null;
    }
  }

  // Remove tags from note
  static async removeTags(id: string, tagsToRemove: string[]): Promise<Note | null> {
    try {
      const note = await this.findById(id);
      if (!note) return null;

      const existingTags = note.tags as string[] || [];
      const updatedTags = existingTags.filter(tag => !tagsToRemove.includes(tag));

      return await this.update(id, { tags: updatedTags });
    } catch (error) {
      console.error('Error removing tags from note:', error);
      return null;
    }
  }

  // Delete note
  static async delete(id: string): Promise<boolean> {
    try {
      await db.delete(notes).where(eq(notes.id, id));
      return true;
    } catch (error) {
      console.error('Error deleting note:', error);
      return false;
    }
  }

  // Delete notes by session
  static async deleteBySession(sessionId: string): Promise<boolean> {
    try {
      await db.delete(notes).where(eq(notes.sessionId, sessionId));
      return true;
    } catch (error) {
      console.error('Error deleting notes by session:', error);
      return false;
    }
  }

  // Get notes count by user
  static async getCountByUser(userId: string): Promise<number> {
    try {
      const result = await db
        .select({ count: notes.id })
        .from(notes)
        .where(eq(notes.userId, userId));
      return result.length;
    } catch (error) {
      console.error('Error getting notes count by user:', error);
      return 0;
    }
  }

  // Get all unique tags for a user
  static async getUserTags(userId: string): Promise<string[]> {
    try {
      const userNotes = await this.findByUserId(userId);
      const allTags = userNotes.flatMap(note => note.tags as string[] || []);
      return [...new Set(allTags)].sort();
    } catch (error) {
      console.error('Error getting user tags:', error);
      return [];
    }
  }

  // Find notes by tag
  static async findByTag(userId: string, tag: string): Promise<Note[]> {
    try {
      const userNotes = await this.findByUserId(userId);
      return userNotes.filter(note => {
        const noteTags = note.tags as string[] || [];
        return noteTags.includes(tag);
      });
    } catch (error) {
      console.error('Error finding notes by tag:', error);
      return [];
    }
  }
}