import { db } from '../neon';
import { notes, type Note, type NewNote } from '@/db/schema';
import { eq, and, desc, like, inArray } from 'drizzle-orm';

export class NoteRepository {
  
  // Create new note
  static async create(noteData: Partial<NewNote> & {
    userId: string;
    sessionId: string;
    title: string;
    content: string;
    type?: 'summary' | 'insight' | 'quote';
    tags?: string[];
    metadata?: Record<string, unknown>;
  }): Promise<Note | null> {
    try {
      const result = await db.insert(notes).values({
        userId: noteData.userId,
        sessionId: noteData.sessionId,
        title: noteData.title,
        content: noteData.content,
        type: noteData.type || 'summary',
        tags: noteData.tags || [],
        metadata: noteData.metadata || {},
        isAutoGenerated: true, // Since we're generating via API
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      return result[0] || null;
    } catch (error) {
      console.error('Error creating note:', error);
      return null;
    }
  }

  // Find note by ID
  static async findById(id: string): Promise<Note | null> {
    try {
      const result = await db.select().from(notes).where(eq(notes.id, id)).limit(1);
      return result[0] || null;
    } catch (error) {
      console.error('Error finding note by ID:', error);
      return null;
    }
  }

  // Find notes by user ID
  static async findByUserId(userId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(eq(notes.userId, userId))
        .orderBy(desc(notes.createdAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by user ID:', error);
      return [];
    }
  }

  // Find notes by session ID
  static async findBySessionId(sessionId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(eq(notes.sessionId, sessionId))
        .orderBy(desc(notes.createdAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by session ID:', error);
      return [];
    }
  }

  // Find notes by user and session
  static async findByUserAndSession(userId: string, sessionId: string): Promise<Note[]> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(and(
          eq(notes.userId, userId),
          eq(notes.sessionId, sessionId)
        ))
        .orderBy(desc(notes.createdAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by user and session:', error);
      return [];
    }
  }

  // Update note
  static async update(id: string, noteData: Partial<NewNote>): Promise<Note | null> {
    try {
      const result = await db
        .update(notes)
        .set({
          ...noteData,
          updatedAt: new Date(),
        })
        .where(eq(notes.id, id))
        .returning();
      return result[0] || null;
    } catch (error) {
      console.error('Error updating note:', error);
      return null;
    }
  }

  // Delete note
  static async delete(id: string): Promise<boolean> {
    try {
      const result = await db.delete(notes).where(eq(notes.id, id)).returning();
      return result.length > 0;
    } catch (error) {
      console.error('Error deleting note:', error);
      return false;
    }
  }

  // Search notes by title or content
  static async search(searchTerm: string, sessionId?: string): Promise<Note[]> {
    try {
      const whereConditions = [
        like(notes.title, `%${searchTerm}%`),
        like(notes.content, `%${searchTerm}%`)
      ];

      const query = db
        .select()
        .from(notes)
        .where(
          and(
            sessionId ? eq(notes.sessionId, sessionId) : undefined,
            // Search in title OR content
            eq(notes.title, searchTerm) // This will be expanded with OR logic
          )
        )
        .orderBy(desc(notes.createdAt));

      // For now, use a simpler approach for search
      let allNotes;
      if (sessionId) {
        allNotes = await db
          .select()
          .from(notes)
          .where(eq(notes.sessionId, sessionId))
          .orderBy(desc(notes.createdAt));
      } else {
        allNotes = await db
          .select()
          .from(notes)
          .orderBy(desc(notes.createdAt));
      }

      // Filter in memory for now (can be optimized later)
      return allNotes.filter(note => 
        note.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
        note.content.toLowerCase().includes(searchTerm.toLowerCase())
      );
    } catch (error) {
      console.error('Error searching notes:', error);
      return [];
    }
  }

  // Find notes by type
  static async findByType(type: 'summary' | 'insight' | 'quote', sessionId?: string): Promise<Note[]> {
    try {
      const whereConditions = [eq(notes.type, type)];
      if (sessionId) {
        whereConditions.push(eq(notes.sessionId, sessionId));
      }

      const result = await db
        .select()
        .from(notes)
        .where(and(...whereConditions))
        .orderBy(desc(notes.createdAt));
      return result;
    } catch (error) {
      console.error('Error finding notes by type:', error);
      return [];
    }
  }

  // Get all available tags for a session
  static async getTagsBySession(sessionId: string): Promise<string[]> {
    try {
      const result = await db
        .select({ tags: notes.tags })
        .from(notes)
        .where(eq(notes.sessionId, sessionId));
      
      // Flatten all tags arrays and get unique values
      const allTags = result
        .flatMap(note => note.tags || [])
        .filter((tag, index, array) => array.indexOf(tag) === index)
        .sort();
        
      return allTags;
    } catch (error) {
      console.error('Error getting tags by session:', error);
      return [];
    }
  }

  // Count notes by session
  static async countBySession(sessionId: string): Promise<number> {
    try {
      const result = await db
        .select()
        .from(notes)
        .where(eq(notes.sessionId, sessionId));
      return result.length;
    } catch (error) {
      console.error('Error counting notes by session:', error);
      return 0;
    }
  }
}