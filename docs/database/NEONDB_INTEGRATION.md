# NeonDB Integration Guide

## Overview

This document explains the comprehensive NeonDB integration that has been implemented to handle all user-related app data, while keeping QdrantDB for vector embeddings and Clerk for user authentication.

## Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     Clerk       │    │     NeonDB      │    │    QdrantDB     │
│ Authentication  │    │   App Data      │    │ Vector Storage  │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • User Sign-up  │    │ • Users         │    │ • Document      │
│ • User Sign-in  │    │ • Documents     │    │   Embeddings    │
│ • Session Mgmt  │    │ • Notes         │    │ • Similarity    │
│ • User Profile  │    │ • Chat History  │    │   Search        │
│                 │    │ • Sessions      │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Database Schema

### Users Table
- Stores user information from Clerk
- Subscription management
- Usage tracking (documents uploaded, messages sent)
- Monthly usage reset functionality

### Documents Table
- Document metadata and content
- Processing status tracking
- File type and size information
- Links to Qdrant collection IDs

### Conversations Table
- Chat conversation metadata
- Document associations
- Session tracking

### Messages Table
- Individual chat messages
- Token counting
- Citations and metadata

### Notes Table
- User-generated and auto-generated notes
- Tags and categorization
- Document associations

### User Sessions Table
- Session activity tracking
- Usage statistics per session
- IP and user agent logging

## Setup Instructions

### 1. NeonDB Database Setup

1. **Get NeonDB Connection String**
   - Visit your NeonDB console
   - Navigate to your project
   - Copy the PostgreSQL connection string
   - Format: `postgresql://username:password@host/database?sslmode=require`

2. **Update Environment Variables**
   ```bash
   # Add to .env.local
   NEON_DATABASE_URL=postgresql://username:password@host/database?sslmode=require
   ```

### 2. Database Migration

```bash
# Generate migrations from schema
npm run db:generate

# Push schema to NeonDB (requires valid connection string)
npm run db:push

# Alternative: Use Drizzle Studio to inspect database
npm run db:studio
```

### 3. Test Connection

```bash
# Test the connection
curl http://localhost:3001/api/test-neon
```

## Repository Pattern

All database operations are handled through repository classes:

### UserRepository
```typescript
import { UserRepository } from '@/lib/repositories/userRepository';

// Get or create user
const user = await UserRepository.getOrCreate(clerkId, email);

// Check permissions
const canUpload = UserRepository.canUploadDocument(user);
const canMessage = UserRepository.canSendMessage(user);
```

### DocumentRepository
```typescript
import { DocumentRepository } from '@/lib/repositories/documentRepository';

// Create document
const doc = await DocumentRepository.create({
  userId: user.id,
  sessionId: sessionId,
  name: 'document.pdf',
  content: 'text content',
  // ... other fields
});

// Get documents by session
const docs = await DocumentRepository.findBySessionId(sessionId);
```

### ConversationRepository & MessageRepository
```typescript
import { ConversationRepository, MessageRepository } from '@/lib/repositories/conversationRepository';

// Create conversation
const conversation = await ConversationRepository.create({
  userId: user.id,
  sessionId: sessionId,
  title: 'Chat about documents',
});

// Add message
const message = await MessageRepository.create({
  conversationId: conversation.id,
  userId: user.id,
  role: 'user',
  content: 'What does this document say?',
});
```

### NotesRepository
```typescript
import { NotesRepository } from '@/lib/repositories/notesRepository';

// Create note
const note = await NotesRepository.create({
  userId: user.id,
  sessionId: sessionId,
  title: 'Summary',
  content: 'Document summary...',
  isAutoGenerated: true,
});

// Search notes
const notes = await NotesRepository.search(user.id, 'keyword');
```

## API Endpoints

### User Management
- `GET /api/user` - Get user data
- `POST /api/user` - Update user (increment usage)

### Document Management
- `GET /api/documents?sessionId=xxx` - Get session documents
- `DELETE /api/documents?documentId=xxx` - Delete document
- `POST /api/upload` - Upload and process document

### Chat Management
- `GET /api/chat?sessionId=xxx` - Get conversations
- `GET /api/chat?conversationId=xxx` - Get conversation history
- `POST /api/chat` - Send message

### Notes Management
- `GET /api/notes?sessionId=xxx` - Get session notes
- `POST /api/notes` - Create note
- `PUT /api/notes` - Update note
- `DELETE /api/notes?noteId=xxx` - Delete note

## Data Flow

### Document Upload Flow
1. **Frontend** uploads file with session ID
2. **Upload API** creates document record in NeonDB
3. **Processing** extracts text and creates chunks
4. **Vector Storage** stores embeddings in Qdrant
5. **Update** document status to 'ready' in NeonDB
6. **Session Tracking** increments document count

### Chat Flow
1. **Frontend** sends message with session/conversation ID
2. **Chat API** creates/finds conversation in NeonDB
3. **Message Storage** saves user message to NeonDB
4. **AI Processing** generates response (separate process)
5. **Response Storage** saves AI response to NeonDB
6. **Usage Tracking** increments message count

### Notes Flow
1. **Auto-generation** creates notes from document analysis
2. **Manual Creation** user creates/edits notes
3. **Storage** saves to NeonDB with document associations
4. **Retrieval** fetches notes by session/user/tags

## Migration from MongoDB

The following changes were made to migrate from MongoDB:

1. **User Model** → **UserRepository** with NeonDB schema
2. **Document Storage** → **DocumentRepository** with metadata in NeonDB
3. **Session Storage** → **SessionRepository** with proper tracking
4. **New Features** → **ConversationRepository**, **MessageRepository**, **NotesRepository**

## Benefits

### 1. **Structured Data Management**
- PostgreSQL provides ACID compliance
- Better data integrity and relationships
- Efficient querying and indexing

### 2. **Scalability**
- NeonDB auto-scaling capabilities
- Serverless PostgreSQL with cold starts
- Connection pooling and optimization

### 3. **Development Experience**
- Type-safe database operations with Drizzle ORM
- Database schema versioning with migrations
- Visual database exploration with Drizzle Studio

### 4. **Separation of Concerns**
- User authentication: Clerk
- Structured data: NeonDB (PostgreSQL)
- Vector operations: QdrantDB
- Each service optimized for its purpose

## Troubleshooting

### Connection Issues
```bash
# Check environment variables
echo $NEON_DATABASE_URL

# Test connection
npm run test-connection
```

### Schema Issues
```bash
# Reset schema (CAUTION: This will delete all data)
npm run db:push --force

# Generate new migration
npm run db:generate
```

### Performance Monitoring
- Monitor query performance in NeonDB console
- Check connection pool usage
- Review slow query logs

## Security Considerations

1. **Connection String Security**
   - Never commit connection strings to version control
   - Use environment variables
   - Rotate credentials regularly

2. **Data Access Control**
   - User isolation through userId fields
   - Session-based access for anonymous users
   - Authorization checks in all API endpoints

3. **Data Privacy**
   - User data is isolated per Clerk user ID
   - Session data is temporary and cleanable
   - Compliance with data retention policies

## Future Enhancements

1. **Read Replicas** for better performance
2. **Database Monitoring** and alerting
3. **Automated Backups** and point-in-time recovery
4. **Connection Pool Optimization**
5. **Query Performance Monitoring**

---

For implementation details, see the individual repository files in `/src/lib/repositories/`.